"""
HiAE (High-throughput Authenticated Encryption) implementation in Python

This is a simple reference implementation following the draft specification.
"""

import struct
from typing import List, Tuple, Optional

# AES S-box
AES_SBOX = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
]

# MixColumns multiplication tables (precomputed for efficiency)
MUL2 = [
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E,
    0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,
    0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E,
    0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E,
    0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E,
    0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE,
    0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE, 0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
    0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE,
    0x1B, 0x19, 0x1F, 0x1D, 0x13, 0x11, 0x17, 0x15, 0x0B, 0x09, 0x0F, 0x0D, 0x03, 0x01, 0x07, 0x05,
    0x3B, 0x39, 0x3F, 0x3D, 0x33, 0x31, 0x37, 0x35, 0x2B, 0x29, 0x2F, 0x2D, 0x23, 0x21, 0x27, 0x25,
    0x5B, 0x59, 0x5F, 0x5D, 0x53, 0x51, 0x57, 0x55, 0x4B, 0x49, 0x4F, 0x4D, 0x43, 0x41, 0x47, 0x45,
    0x7B, 0x79, 0x7F, 0x7D, 0x73, 0x71, 0x77, 0x75, 0x6B, 0x69, 0x6F, 0x6D, 0x63, 0x61, 0x67, 0x65,
    0x9B, 0x99, 0x9F, 0x9D, 0x93, 0x91, 0x97, 0x95, 0x8B, 0x89, 0x8F, 0x8D, 0x83, 0x81, 0x87, 0x85,
    0xBB, 0xB9, 0xBF, 0xBD, 0xB3, 0xB1, 0xB7, 0xB5, 0xAB, 0xA9, 0xAF, 0xAD, 0xA3, 0xA1, 0xA7, 0xA5,
    0xDB, 0xD9, 0xDF, 0xDD, 0xD3, 0xD1, 0xD7, 0xD5, 0xCB, 0xC9, 0xCF, 0xCD, 0xC3, 0xC1, 0xC7, 0xC5,
    0xFB, 0xF9, 0xFF, 0xFD, 0xF3, 0xF1, 0xF7, 0xF5, 0xEB, 0xE9, 0xEF, 0xED, 0xE3, 0xE1, 0xE7, 0xE5,
]

MUL3 = [
    0x00, 0x03, 0x06, 0x05, 0x0C, 0x0F, 0x0A, 0x09, 0x18, 0x1B, 0x1E, 0x1D, 0x14, 0x17, 0x12, 0x11,
    0x30, 0x33, 0x36, 0x35, 0x3C, 0x3F, 0x3A, 0x39, 0x28, 0x2B, 0x2E, 0x2D, 0x24, 0x27, 0x22, 0x21,
    0x60, 0x63, 0x66, 0x65, 0x6C, 0x6F, 0x6A, 0x69, 0x78, 0x7B, 0x7E, 0x7D, 0x74, 0x77, 0x72, 0x71,
    0x50, 0x53, 0x56, 0x55, 0x5C, 0x5F, 0x5A, 0x59, 0x48, 0x4B, 0x4E, 0x4D, 0x44, 0x47, 0x42, 0x41,
    0xC0, 0xC3, 0xC6, 0xC5, 0xCC, 0xCF, 0xCA, 0xC9, 0xD8, 0xDB, 0xDE, 0xDD, 0xD4, 0xD7, 0xD2, 0xD1,
    0xF0, 0xF3, 0xF6, 0xF5, 0xFC, 0xFF, 0xFA, 0xF9, 0xE8, 0xEB, 0xEE, 0xED, 0xE4, 0xE7, 0xE2, 0xE1,
    0xA0, 0xA3, 0xA6, 0xA5, 0xAC, 0xAF, 0xAA, 0xA9, 0xB8, 0xBB, 0xBE, 0xBD, 0xB4, 0xB7, 0xB2, 0xB1,
    0x90, 0x93, 0x96, 0x95, 0x9C, 0x9F, 0x9A, 0x99, 0x88, 0x8B, 0x8E, 0x8D, 0x84, 0x87, 0x82, 0x81,
    0x9B, 0x98, 0x9D, 0x9E, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8F, 0x8C, 0x89, 0x8A,
    0xAB, 0xA8, 0xAD, 0xAE, 0xA7, 0xA4, 0xA1, 0xA2, 0xB3, 0xB0, 0xB5, 0xB6, 0xBF, 0xBC, 0xB9, 0xBA,
    0xFB, 0xF8, 0xFD, 0xFE, 0xF7, 0xF4, 0xF1, 0xF2, 0xE3, 0xE0, 0xE5, 0xE6, 0xEF, 0xEC, 0xE9, 0xEA,
    0xCB, 0xC8, 0xCD, 0xCE, 0xC7, 0xC4, 0xC1, 0xC2, 0xD3, 0xD0, 0xD5, 0xD6, 0xDF, 0xDC, 0xD9, 0xDA,
    0x5B, 0x58, 0x5D, 0x5E, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4F, 0x4C, 0x49, 0x4A,
    0x6B, 0x68, 0x6D, 0x6E, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7F, 0x7C, 0x79, 0x7A,
    0x3B, 0x38, 0x3D, 0x3E, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2F, 0x2C, 0x29, 0x2A,
    0x0B, 0x08, 0x0D, 0x0E, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1F, 0x1C, 0x19, 0x1A,
]

# Constants C0 and C1
C0 = bytes([0x32, 0x43, 0xF6, 0xA8, 0x88, 0x5A, 0x30, 0x8D, 0x31, 0x31, 0x98, 0xA2, 0xE0, 0x37, 0x07, 0x34])
C1 = bytes([0x4A, 0x40, 0x93, 0x82, 0x22, 0x99, 0xF3, 0x1D, 0x00, 0x82, 0xEF, 0xA9, 0x8E, 0xC4, 0xE6, 0xC8])


def bytes_to_state(data: bytes) -> List[List[int]]:
    """Convert 16 bytes to 4x4 AES state matrix (column-major order)"""
    state = [[0 for _ in range(4)] for _ in range(4)]
    for i in range(16):
        state[i % 4][i // 4] = data[i]
    return state


def state_to_bytes(state: List[List[int]]) -> bytes:
    """Convert 4x4 AES state matrix to 16 bytes (column-major order)"""
    result = bytearray(16)
    for i in range(16):
        result[i] = state[i % 4][i // 4]
    return bytes(result)


def sub_bytes(state: List[List[int]]) -> List[List[int]]:
    """Apply AES SubBytes transformation"""
    for i in range(4):
        for j in range(4):
            state[i][j] = AES_SBOX[state[i][j]]
    return state


def shift_rows(state: List[List[int]]) -> List[List[int]]:
    """Apply AES ShiftRows transformation"""
    # Row 0: no shift
    # Row 1: shift left by 1
    state[1][0], state[1][1], state[1][2], state[1][3] = (
        state[1][1],
        state[1][2],
        state[1][3],
        state[1][0],
    )
    # Row 2: shift left by 2
    state[2][0], state[2][1], state[2][2], state[2][3] = (
        state[2][2],
        state[2][3],
        state[2][0],
        state[2][1],
    )
    # Row 3: shift left by 3
    state[3][0], state[3][1], state[3][2], state[3][3] = (
        state[3][3],
        state[3][0],
        state[3][1],
        state[3][2],
    )
    return state


def mix_columns(state: List[List[int]]) -> List[List[int]]:
    """Apply AES MixColumns transformation"""
    for c in range(4):
        s0, s1, s2, s3 = state[0][c], state[1][c], state[2][c], state[3][c]
        state[0][c] = MUL2[s0] ^ MUL3[s1] ^ s2 ^ s3
        state[1][c] = s0 ^ MUL2[s1] ^ MUL3[s2] ^ s3
        state[2][c] = s0 ^ s1 ^ MUL2[s2] ^ MUL3[s3]
        state[3][c] = MUL3[s0] ^ s1 ^ s2 ^ MUL2[s3]
    return state


def aesl(block: bytes) -> bytes:
    """
    Apply AESL transformation: MixColumns(ShiftRows(SubBytes(x)))
    This is a single AES round without AddRoundKey
    """
    state = bytes_to_state(block)
    state = sub_bytes(state)
    state = shift_rows(state)
    state = mix_columns(state)
    return state_to_bytes(state)


def xor_bytes(a: bytes, b: bytes) -> bytes:
    """XOR two byte arrays of equal length"""
    return bytes(x ^ y for x, y in zip(a, b))


def le64(n: int) -> bytes:
    """Convert integer to 8-byte little-endian representation"""
    return struct.pack("<Q", n)


def zero_pad(data: bytes, block_size_bits: int) -> bytes:
    """Pad data with zeros to multiple of block_size_bits"""
    block_size_bytes = block_size_bits // 8
    if len(data) % block_size_bytes == 0:
        return data
    padding_needed = block_size_bytes - (len(data) % block_size_bytes)
    return data + b"\x00" * padding_needed


def truncate(data: bytes, n_bits: int) -> bytes:
    """Return first n bits of data"""
    n_bytes = n_bits // 8
    if n_bits % 8 == 0:
        return data[:n_bytes]
    else:
        # Handle partial byte
        result = bytearray(data[: n_bytes + 1])
        mask = (1 << (n_bits % 8)) - 1
        result[-1] &= mask
        return bytes(result)


def split(data: bytes, block_size_bits: int) -> List[bytes]:
    """Split data into blocks of specified size, ignoring partial blocks"""
    block_size_bytes = block_size_bits // 8
    blocks = []
    for i in range(0, len(data), block_size_bytes):
        if i + block_size_bytes <= len(data):
            blocks.append(data[i : i + block_size_bytes])
    return blocks


def tail(data: bytes, n_bits: int) -> bytes:
    """Return last n bits of data"""
    n_bytes = n_bits // 8
    n_bits_partial = n_bits % 8

    if n_bits_partial == 0:
        return data[-n_bytes:] if n_bytes <= len(data) else data
    else:
        # Handle partial byte case
        total_bytes_needed = n_bytes + 1
        if total_bytes_needed > len(data):
            return data

        result = bytearray(data[-total_bytes_needed:])
        # Mask the first byte to get only the needed bits
        shift = 8 - n_bits_partial
        result[0] = (result[0] >> shift) << shift
        return bytes(result)


def ct_eq(a: bytes, b: bytes) -> bool:
    """Constant-time comparison of two byte arrays"""
    if len(a) != len(b):
        return False

    result = 0
    for x, y in zip(a, b):
        result |= x ^ y

    return result == 0


class HiAE:
    """HiAE authenticated encryption implementation"""

    def __init__(self):
        # State: 16 AES blocks of 128 bits each
        self.state = [b"\x00" * 16 for _ in range(16)]

    def rol(self):
        """Rotate state blocks left by one position"""
        temp = self.state[0]
        for i in range(15):
            self.state[i] = self.state[i + 1]
        self.state[15] = temp

    def update(self, xi: bytes):
        """Core update function"""
        t = xor_bytes(aesl(xor_bytes(self.state[0], self.state[1])), xi)
        self.state[0] = xor_bytes(aesl(self.state[13]), t)
        self.state[3] = xor_bytes(self.state[3], xi)
        self.state[13] = xor_bytes(self.state[13], xi)
        self.rol()

    def update_enc(self, mi: bytes) -> bytes:
        """Update function with encryption"""
        t = xor_bytes(aesl(xor_bytes(self.state[0], self.state[1])), mi)
        ci = xor_bytes(t, self.state[9])
        self.state[0] = xor_bytes(aesl(self.state[13]), t)
        self.state[3] = xor_bytes(self.state[3], mi)
        self.state[13] = xor_bytes(self.state[13], mi)
        self.rol()
        return ci

    def update_dec(self, ci: bytes) -> bytes:
        """Update function with decryption"""
        t = xor_bytes(ci, self.state[9])
        mi = xor_bytes(aesl(xor_bytes(self.state[0], self.state[1])), t)
        self.state[0] = xor_bytes(aesl(self.state[13]), t)
        self.state[3] = xor_bytes(self.state[3], mi)
        self.state[13] = xor_bytes(self.state[13], mi)
        self.rol()
        return mi

    def diffuse(self, x: bytes):
        """Apply 32 update rounds for full diffusion"""
        for _ in range(32):
            self.update(x)

    def init(self, key: bytes, nonce: bytes):
        """Initialize state from key and nonce"""
        # Split key into two 128-bit halves
        k0 = key[:16]
        k1 = key[16:32]

        # Initialize state blocks
        self.state[0] = C0
        self.state[1] = k1
        self.state[2] = nonce
        self.state[3] = C0
        self.state[4] = b"\x00" * 16
        self.state[5] = xor_bytes(nonce, k0)
        self.state[6] = b"\x00" * 16
        self.state[7] = C1
        self.state[8] = xor_bytes(nonce, k1)
        self.state[9] = b"\x00" * 16
        self.state[10] = k1
        self.state[11] = C0
        self.state[12] = C1
        self.state[13] = k1
        self.state[14] = b"\x00" * 16
        self.state[15] = xor_bytes(C0, C1)

        # Diffuse with C0
        self.diffuse(C0)

        # Final XORs
        self.state[9] = xor_bytes(self.state[9], k0)
        self.state[13] = xor_bytes(self.state[13], k1)

    def absorb(self, ai: bytes):
        """Absorb a block of associated data"""
        self.update(ai)

    def enc(self, mi: bytes) -> bytes:
        """Encrypt a single block"""
        return self.update_enc(mi)

    def dec(self, ci: bytes) -> bytes:
        """Decrypt a single block"""
        return self.update_dec(ci)

    def dec_partial(self, cn: bytes) -> bytes:
        """Decrypt a partial block"""
        # Step 1: Recover keystream
        ks = xor_bytes(
            xor_bytes(aesl(xor_bytes(self.state[0], self.state[1])), zero_pad(cn, 128)),
            self.state[9],
        )

        # Step 2: Construct full ciphertext block
        ci = cn + tail(ks, 128 - len(cn) * 8)

        # Step 3: Decrypt full block
        mi = self.update_dec(ci)

        # Step 4: Extract partial plaintext
        mn = truncate(mi, len(cn) * 8)

        return mn

    def finalize(self, ad_len_bits: int, msg_len_bits: int) -> bytes:
        """Generate authentication tag"""
        t = le64(ad_len_bits) + le64(msg_len_bits)
        self.diffuse(t)

        # XOR all state blocks
        tag = self.state[0]
        for i in range(1, 16):
            tag = xor_bytes(tag, self.state[i])

        return tag


def encrypt(msg: bytes, ad: bytes, key: bytes, nonce: bytes) -> Tuple[bytes, bytes]:
    """
    Encrypt message with associated data
    Returns (ciphertext, tag)
    """
    hiae = HiAE()
    hiae.init(key, nonce)

    ct = b""

    # Process associated data
    ad_blocks = split(zero_pad(ad, 128), 128)
    for ai in ad_blocks:
        hiae.absorb(ai)

    # Encrypt message
    msg_blocks = split(zero_pad(msg, 128), 128)
    for xi in msg_blocks:
        ct += hiae.enc(xi)

    # Generate tag
    tag = hiae.finalize(len(ad) * 8, len(msg) * 8)

    # Truncate ciphertext to message length
    ct = truncate(ct, len(msg) * 8)

    return ct, tag


def decrypt(
    ct: bytes, tag: bytes, ad: bytes, key: bytes, nonce: bytes
) -> Optional[bytes]:
    """
    Decrypt ciphertext and verify tag
    Returns plaintext if tag is valid, None otherwise
    """
    hiae = HiAE()
    hiae.init(key, nonce)

    msg = b""

    # Process associated data
    ad_blocks = split(zero_pad(ad, 128), 128)
    for ai in ad_blocks:
        hiae.absorb(ai)

    # Decrypt ciphertext
    ct_blocks = split(ct, 128)
    cn = tail(ct, len(ct) * 8 % 128) if len(ct) % 16 != 0 else b""

    for ci in ct_blocks:
        msg += hiae.dec(ci)

    if cn:
        msg += hiae.dec_partial(cn)

    # Generate expected tag
    expected_tag = hiae.finalize(len(ad) * 8, len(msg) * 8)

    # Verify tag
    if not ct_eq(tag, expected_tag):
        return None

    return msg
